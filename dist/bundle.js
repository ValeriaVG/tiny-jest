(()=>{var c=(e,t,r)=>new Promise((o,s)=>{var f=i=>{try{a(r.next(i))}catch(y){s(y)}},g=i=>{try{a(r.throw(i))}catch(y){s(y)}},a=i=>i.done?o(i.value):Promise.resolve(i.value).then(f,g);a((r=r.apply(e,t)).next())});var u=class{constructor(t){this.suite=[];this.results=[];this._before=[];this._after=[];this.it=(t,r)=>{this.suite.push({title:t,fn:r})};this.xit=(t,r)=>{this.suite.push({title:t})};this.run=()=>c(this,null,function*(){this.results=[];try{yield Promise.all(this._before.map(t=>t()))}catch(t){return[{title:this.title,error:t,passed:!1}]}for(let t of this.suite){if(!t.fn){this.results.push({title:t.title,skipped:!0});continue}try{yield t.fn(),this.results.push({title:t.title,passed:!0})}catch(r){this.results.push({title:t.title,error:r,passed:!1})}}try{yield Promise.all(this._after.map(t=>t()))}catch(t){console.error(t)}return this.results});this.before=t=>{this._before.push(t)};this.after=t=>{this._after.push(t)};this.title=t!=null?t:""}};var p=class extends Error{constructor(t,r,o,s){super(s);this.extensions={matcher:t,expected:r,actual:o}}},n={toBe:(e,t)=>t===e?!1:`Expected ${JSON.stringify(e)} to be ${JSON.stringify(t)}`,toEqual:(e,t)=>t==e?!1:`Expected ${JSON.stringify(e)} to equal ${JSON.stringify(t)}`,toBeTruthy:e=>e?!1:`Expected ${JSON.stringify(e)} to be truthy`,toBeFalsy:e=>e?`Expected ${JSON.stringify(e)} to be falsy`:!1,toMatchObject:(e,t)=>{let r=`${JSON.stringify(e)} does not match ${JSON.stringify(t)}`;if(typeof e!=typeof t||Array.isArray(e)!==Array.isArray(t))return r;for(let o in t){if(typeof e[o]!=typeof t[o])return`${r}:
Types mismatch for ${o}: ${typeof e[o]} != ${typeof t[o]}`;if(typeof t[o]!="object"){if(n.toBe(e[o],t[o]))return`Mismatched "${o}": ${JSON.stringify(e[o])} != ${JSON.stringify(t[o])}`;continue}let s=n.toMatchObject(e[o],t[o]);if(s)return s}return!1},toThrow:(e,t)=>{try{return e(),`Expected ${e.toString()} to throw error ${t&&` matching ${t.toString()}`}`}catch(r){return!t||t.test(r.toString())?!1:`Expected ${e.toString()} to throw error ${t&&` matching ${t.toString()}, but got ${r.toString()} instead`}`}}};function l(e){let t={not:{}};return Object.keys(n).forEach(r=>{t[r]=o=>{let s=n[r](e,o);if(s)throw new p(r,o,e,s)},t.not[r]=o=>{if(n[r](e,o)===!1)throw new p(r,o,e,`Expected ${JSON.stringify(e)} not ${r.replace(/[A-Z]/g,f=>` ${f.toLowerCase()}`)}${typeof o!="undefined"?" "+JSON.stringify(o):""}`)}}),t}function h(e){e.forEach(({title:t,passed:r,skipped:o,error:s})=>{if(r)return console.info("[32m",`\u2713 ${t}`);if(o)return console.info("[33m",`\u25A1 ${t}`);if(!r)return console.error("[31m",`\u{10102} ${t}`,`
  Failed:`,s.message)}),console.log("[0m")}})();
//# sourceMappingURL=bundle.js.map
