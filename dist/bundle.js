(()=>{var l=Object.defineProperty;var m=s=>l(s,"__esModule",{value:!0});var E=(s,t)=>{m(s);for(var e in t)l(s,e,{get:t[e],enumerable:!0})};var $=(s,t,e)=>new Promise((o,r)=>{var a=n=>{try{f(e.next(n))}catch(u){r(u)}},x=n=>{try{f(e.throw(n))}catch(u){r(u)}},f=n=>n.done?o(n.value):Promise.resolve(n.value).then(a,x);f((e=e.apply(s,t)).next())});var h={};E(h,{Test:()=>p,expect:()=>y,prettify:()=>c});var p=class{constructor(t){this.suite=[];this.results=[];this._before=[];this._after=[];this.it=(t,e)=>{this.suite.push({title:t,fn:e})};this.xit=(t,e)=>{this.suite.push({title:t})};this.run=()=>$(this,null,function*(){this.results=[];try{yield Promise.all(this._before.map(t=>t()))}catch(t){return[{title:this.title,error:t,passed:!1}]}for(let t of this.suite){if(!t.fn){this.results.push({title:t.title,skipped:!0});continue}try{yield t.fn(),this.results.push({title:t.title,passed:!0})}catch(e){this.results.push({title:t.title,error:e,passed:!1})}}try{yield Promise.all(this._after.map(t=>t()))}catch(t){console.error(t)}return this.results});this.before=t=>{this._before.push(t)};this.after=t=>{this._after.push(t)};this.title=t!=null?t:""}};var g=class extends Error{constructor(t,e,o,r){super(r);this.extensions={matcher:t,expected:e,actual:o}}},i={toBe:(s,t,e)=>({pass:e===t,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to be ${JSON.stringify(e)}`}),toEqual:(s,t,e)=>({pass:e==t,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to equal ${JSON.stringify(e)}`}),toBeTruthy:(s,t)=>({pass:!!t,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to be truthy`}),toBeFalsy:(s,t)=>({pass:!t,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to be falsy`}),toMatchObject:(s,t,e)=>{let o=`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to match ${JSON.stringify(e)}`;if(typeof t!=typeof e||Array.isArray(t)!==Array.isArray(e))return{pass:!1,message:()=>o};for(let r in e){if(typeof t[r]!=typeof e[r])return{pass:!1,message:()=>`${o}:
Types mismatch for ${r}: ${typeof t[r]} != ${typeof e[r]}`};if(typeof e[r]!="object"){if(!i.toBe(s,t[r],e[r]).pass)return{pass:!1,message:()=>`${o}: Mismatched "${r}": ${JSON.stringify(t[r])} != ${JSON.stringify(e[r])}`};continue}let a=i.toMatchObject(s,t[r],e[r]);if(!a.pass)return a}return{pass:!0,message:()=>o}},toThrow:(s,t,e)=>{let o=`Expected ${t.toString()}${s.isNot?" not":""} to throw error ${e&&` matching ${e.toString()}`}`;try{return t(),{pass:!1,message:()=>o}}catch(r){return!e||e.test(r.toString())?{pass:!0,message:()=>o}:{pass:!1,message:()=>`Expected ${t.toString()}${s.isNot?" not":""} to throw error ${e&&` matching ${e.toString()}, but got ${r.toString()} instead`}`}}},toBeGreaterThan:(s,t,e)=>({pass:t>e,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to be greater than ${JSON.stringify(e)}`}),toBeGreaterThanOrEqual:(s,t,e)=>({pass:t>=e,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to be greater than or equal ${JSON.stringify(e)}`}),toBeLessThan:(s,t,e)=>({pass:t<e,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to be less than ${JSON.stringify(e)}`}),toBeLessThanOrEqual:(s,t,e)=>({pass:t<=e,message:()=>`Expected ${JSON.stringify(t)}${s.isNot?" not":""} to be less than or equal ${JSON.stringify(e)}`})};function y(s){let t={not:{}};return Object.keys(i).forEach(e=>{t[e]=o=>{let r=i[e]({isNot:!1},s,o);if(!r.pass)throw new g(e,o,s,r.message())},t.not[e]=o=>{let r=i[e]({isNot:!0},s,o);if(r.pass)throw new g(e,o,s,r.message())}}),t}y.extend=s=>{Object.assign(i,s)};function c(s){s.forEach(({title:t,passed:e,skipped:o,error:r})=>{if(e)return console.info("[32m",`\u2713 ${t}`);if(o)return console.info("[33m",`\u25A1 ${t}`);if(!e)return console.error("[31m",`\u{10102} ${t}`,`
  Failed:`,r.message)}),console.log("[0m")}window.tinyJest=h;})();
//# sourceMappingURL=bundle.js.map
