{
  "version": 3,
  "sources": ["../src/index.ts", "../src/Test.ts", "../src/expect.ts", "../src/prettify.ts", "../src/browser.ts"],
  "sourcesContent": ["export { default as Test } from \"./Test\";\nexport { default as expect } from \"./expect\";\nexport { default as prettify } from \"./prettify\";\n", "export type TestResult = {\n  title: string;\n  skipped?: boolean;\n  passed?: boolean;\n  error?: Error;\n};\n\nexport type FixtureFn = () => Promise<void> | void;\nexport default class Test {\n  title: string;\n  suite: { title: string; fn?: Function }[] = [];\n  // Stores last results\n  results: TestResult[] = [];\n  private _before: FixtureFn[] = [];\n  private _after: FixtureFn[] = [];\n  constructor(title?: string) {\n    this.title = title ?? \"\";\n  }\n  it = (title: string, fn?: Function) => {\n    this.suite.push({ title, fn });\n  };\n  xit = (title: string, _fn?: Function) => {\n    this.suite.push({ title });\n  };\n  run = async (): Promise<TestResult[]> => {\n    this.results = [];\n    try {\n      await Promise.all(this._before.map((fn) => fn()));\n    } catch (error) {\n      return [{ title: this.title, error, passed: false }];\n    }\n    for (let test of this.suite) {\n      if (!test.fn) {\n        this.results.push({ title: test.title, skipped: true });\n        continue;\n      }\n      try {\n        await test.fn();\n        this.results.push({ title: test.title, passed: true });\n      } catch (error) {\n        this.results.push({ title: test.title, error, passed: false });\n      }\n    }\n    try {\n      await Promise.all(this._after.map((fn) => fn()));\n    } catch (error) {\n      console.error(error);\n    }\n    return this.results;\n  };\n  before = (fn: FixtureFn) => {\n    this._before.push(fn);\n  };\n  after = (fn: FixtureFn) => {\n    this._after.push(fn);\n  };\n}\n", "export class ExpectationError extends Error {\n  extensions: { matcher: string; expected: any; actual: any };\n  constructor(matcher: string, expected: any, actual: any, diff: string) {\n    super(diff);\n    this.extensions = { matcher, expected, actual };\n  }\n}\n\nexport type Expectation<T> = (expected: T) => void;\n\nexport type Expectations = {\n  toBe: Expectation<any>;\n  toEqual: Expectation<any>;\n  toBeTruthy: Expectation<void>;\n  toBeFalsy: Expectation<void>;\n  toMatchObject: Expectation<Object>;\n  toThrow: Expectation<RegExp | void>;\n  toBeGreaterThan: Expectation<number>;\n  toBeGreaterThanOrEqual: Expectation<number>;\n  toBeLessThan: Expectation<number>;\n  toBeLessThanOrEqual: Expectation<number>;\n};\n\nexport type Matcher = (actual: any, expected: any) => false | string;\n\nconst matchers: Record<keyof Expectations, Matcher> = {\n  toBe: (actual: any, expected: any) => {\n    return expected === actual\n      ? false\n      : `Expected ${JSON.stringify(actual)} to be ${JSON.stringify(expected)}`;\n  },\n  toEqual: (actual: any, expected: any) => {\n    return expected == actual\n      ? false\n      : `Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(\n          expected\n        )}`;\n  },\n  toBeTruthy: (actual: any) => {\n    return actual ? false : `Expected ${JSON.stringify(actual)} to be truthy`;\n  },\n  toBeFalsy: (actual: any) => {\n    return actual ? `Expected ${JSON.stringify(actual)} to be falsy` : false;\n  },\n  toMatchObject: (actual: any, expected: any): string | false => {\n    const error = `${JSON.stringify(actual)} does not match ${JSON.stringify(\n      expected\n    )}`;\n    if (\n      typeof actual !== typeof expected ||\n      Array.isArray(actual) !== Array.isArray(expected)\n    )\n      return error;\n    for (let key in expected) {\n      if (typeof actual[key] !== typeof expected[key])\n        return `${error}:\\nTypes mismatch for ${key}: ${typeof actual[\n          key\n        ]} != ${typeof expected[key]}`;\n      if (typeof expected[key] !== \"object\") {\n        const res = matchers.toBe(actual[key], expected[key]);\n        if (res)\n          return `Mismatched \"${key}\": ${JSON.stringify(\n            actual[key]\n          )} != ${JSON.stringify(expected[key])}`;\n        continue;\n      }\n      const res = matchers.toMatchObject(actual[key], expected[key]);\n      if (res) return res;\n    }\n    return false;\n  },\n  toThrow: (fn: Function, expression?: RegExp): string | false => {\n    try {\n      fn();\n      return `Expected ${fn.toString()} to throw error ${\n        expression && ` matching ${expression.toString()}`\n      }`;\n    } catch (err) {\n      if (!expression || expression.test(err.toString())) return false;\n      return `Expected ${fn.toString()} to throw error ${\n        expression &&\n        ` matching ${expression.toString()}, but got ${err.toString()} instead`\n      }`;\n    }\n  },\n  toBeGreaterThan: (actual: any, expected: any) => {\n    return actual > expected\n      ? false\n      : `Expected ${JSON.stringify(actual)} to be greater than ${JSON.stringify(\n          expected\n        )}`;\n  },\n  toBeGreaterThanOrEqual: (actual: any, expected: any) => {\n    return actual >= expected\n      ? false\n      : `Expected ${JSON.stringify(\n          actual\n        )} to be greater than or equal ${JSON.stringify(expected)}`;\n  },\n  toBeLessThan: (actual: any, expected: any) => {\n    return actual < expected\n      ? false\n      : `Expected ${JSON.stringify(actual)} to be less than ${JSON.stringify(\n          expected\n        )}`;\n  },\n  toBeLessThanOrEqual: (actual: any, expected: any) => {\n    return actual <= expected\n      ? false\n      : `Expected ${JSON.stringify(\n          actual\n        )} to be less than or equal ${JSON.stringify(expected)}`;\n  },\n};\n\nexport default function expect(\n  actual: any\n): Expectations & { not: Expectations } {\n  const expectation: any = {\n    not: {},\n  };\n  (Object.keys(matchers) as Array<keyof Expectations>).forEach((matcher) => {\n    expectation[matcher] = (expected: any) => {\n      const diff = matchers[matcher](actual, expected);\n      if (diff) throw new ExpectationError(matcher, expected, actual, diff);\n    };\n    expectation.not[matcher] = (expected: any) => {\n      const diff = matchers[matcher](actual, expected);\n      if (diff === false)\n        throw new ExpectationError(\n          matcher,\n          expected,\n          actual,\n          `Expected ${JSON.stringify(actual)} not ${matcher.replace(\n            /[A-Z]/g,\n            (letter) => ` ${letter.toLowerCase()}`\n          )}${\n            typeof expected !== \"undefined\"\n              ? \" \" + JSON.stringify(expected)\n              : \"\"\n          }`\n        );\n    };\n  });\n  return expectation;\n}\n", "import { TestResult } from \"./test\";\n\nexport default function prettify(testResults: TestResult[]) {\n  testResults.forEach(({ title, passed, skipped, error }) => {\n    if (passed) return console.info(\"\\x1b[32m\", `\u2713 ${title}`);\n    if (skipped) return console.info(\"\\x1b[33m\", `\u25A1 ${title}`);\n    if (!passed)\n      return console.error(\n        \"\\x1b[31m\",\n        `\uD800\uDD02 ${title}`,\n        \"\\n  Failed:\",\n        error!.message\n      );\n  });\n  console.log(\"\\x1b[0m\");\n}\n", "import * as tinyJest from \"./index\";\n//@ts-ignore\nwindow[\"tinyJest\"] = tinyJest;\n"],
  "mappings": "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",
  "names": []
}
